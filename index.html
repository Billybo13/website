<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>AI + Humanity — Music Visualizer (No Center Pull Idle)</title>
<style>
html, body { margin:0; padding:0; overflow:hidden; background:#000; color:#fff; height:100%; }
canvas { position:fixed; inset:0; z-index:0; }

/* Cylinder + quotes */
.carousel-container {
  position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  perspective:2000px; width:80vw; height:30vh; z-index:1;
}
.cylinder-wrap { position:absolute; inset:0; transform-style:preserve-3d; pointer-events:none; z-index:0; }
.ring-panel {
  position:absolute; left:50%; top:50%; transform-origin:center center;
  width: var(--stripW, 24px);
  height: 30vh;
  margin-left: calc(var(--stripW, 24px) / -2);
  margin-top: calc(30vh / -2);
  border-radius: 6px;
  background:
    linear-gradient(90deg,
      rgba(255,255,255,0.16) 0%,
      rgba(255,255,255,0.08) 22%,
      rgba(255,255,255,0.02) 52%,
      rgba(0,0,0,0.28) 100%);
  opacity: 0.35;
  backdrop-filter: blur(2px) saturate(115%);
  -webkit-backdrop-filter: blur(2px) saturate(115%);
  box-shadow: inset 0 0 12px rgba(255,255,255,0.06), 0 0 24px rgba(0,0,0,0.28);
}
.carousel { position:absolute; inset:0; transform-style:preserve-3d; z-index:1; }
.carousel-panel{
  position:absolute; width:80vw; height:30vh; display:flex; justify-content:center; align-items:center;
  font-size:clamp(1rem,2.2vw,2.5rem); font-weight:700; text-align:center; padding:2vw; box-sizing:border-box;
  background: rgba(255,255,255,0.05);
  backdrop-filter: blur(16px) saturate(140%);
  -webkit-backdrop-filter: blur(16px) saturate(140%);
  border: 1px solid rgba(255,255,255,0.12);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.18), 0 10px 30px rgba(0,0,0,0.25);
  border-radius:1vw;
  transition:text-shadow .2s ease;
}

/* Play/Pause */
button{
  position:fixed; top:1rem; left:1rem; padding:.5rem 1rem; font-size:1rem;
  background:teal; border:0; border-radius:.5rem; color:#fff; cursor:pointer; z-index:2;
}
</style>
</head>
<body>
<canvas id="bg"></canvas>

<div class="carousel-container">
  <div class="cylinder-wrap" id="cylinderRing"></div>
  <div class="carousel" id="carousel"></div>
</div>

<button id="toggleAudio">Play</button>

<script>
/* ====== Config ====== */
const AUDIO_FILE = "Dubdeath .wav"; // exact filename (space included)
const BASE_PARTICLE_COUNT = 1000;
const FLARE_POOL_SIZE = 30;         // subtle
const CORE_RADIUS = 80;            // small core exclusion
const CENTER_CONTAIN = 0.010;       // now auto-scales with audio energy

/* ====== Quotes / Cylinder ====== */
const quotes = [
  "AI will enhance human creativity, not replace it.",
  "Technology can amplify empathy and understanding.",
  "The future is built on collaboration between humans and machines.",
  "Artificial intelligence will help us solve global challenges.",
  "Automation can free humanity to focus on what matters most.",
  "AI can guide us toward sustainable innovation."
];

const carousel = document.getElementById("carousel");
const ring = document.getElementById("cylinderRing");
const panelCount = quotes.length;
const panelWidth = 0.8 * innerWidth;
const radius = Math.round((panelWidth / 2) / Math.tan(Math.PI / panelCount));

quotes.forEach((q, i) => {
  const el = document.createElement("div");
  el.className = "carousel-panel";
  el.textContent = q;
  const angle = (360 / panelCount) * i;
  el.style.transform = `rotateY(${angle}deg) translateZ(${radius}px)`;
  carousel.appendChild(el);
});
const panels = document.querySelectorAll(".carousel-panel");

/* Cylindrical backdrop ring */
const segmentCount = 60;
const stripW = Math.max(8, Math.floor((2 * Math.PI * radius) / segmentCount));
ring.style.setProperty('--stripW', stripW + 'px');
for (let i = 0; i < segmentCount; i++) {
  const seg = document.createElement('div');
  seg.className = 'ring-panel';
  const angle = i * (360 / segmentCount);
  const tilt = Math.sin((i / segmentCount) * Math.PI * 2) * 0.6;
  seg.style.transform = `rotateY(${angle}deg) rotateX(${tilt}deg) translateZ(${radius}px)`;
  ring.appendChild(seg);
}

/* ====== Canvas / Visualizer ====== */
const canvas = document.getElementById("bg");
const ctx = canvas.getContext("2d", { alpha:true });
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener("resize", resize); resize();

const lerp = (a,b,t)=> a + (b-a)*t;
const clamp = (x,a,b)=> Math.min(b, Math.max(a, x));

/* --- Pointer (no lingering; reacts only to recent movement) --- */
const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
const pointer = {
  x: innerWidth/2,
  y: innerHeight/2,
  active: false,                                // true while pressed
  strength: isTouch ? 2.0 : 1.0,
  lastMove: 0                                    // timestamp of last move
};
function markMove(x, y){ pointer.x = x; pointer.y = y; pointer.lastMove = performance.now(); }
// Mouse
addEventListener('mousemove', e => { markMove(e.clientX, e.clientY); });
addEventListener('mousedown', e => { pointer.active = true; markMove(e.clientX, e.clientY); });
addEventListener('mouseup',   () => { pointer.active = false; });
// Touch
addEventListener('touchstart', e => {
  const t = e.touches[0]; pointer.active = true; markMove(t.clientX, t.clientY);
}, {passive:false});
addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0]; markMove(t.clientX, t.clientY);
}, {passive:false});
addEventListener('touchend',  () => { pointer.active = false; });

/* ----- Particles ----- */
let audioEnergy = 0; // 0..1 overall energy (drives containment on/off)

class Particle {
  constructor(){
    this.x = Math.random()*canvas.width;
    this.y = Math.random()*canvas.height;
    this.vx = (Math.random()-0.5)*0.22;
    this.vy = (Math.random()-0.5)*0.22;
    this.baseSize = 0.6 + Math.random()*0.9; // tiny speckles
    this.size = this.baseSize;
    this.hue = Math.random()*360;
    this.color = `hsl(${this.hue},100%,70%)`;
  }
  update(bassN, midN, trebN, centroidN, beatBoost, musicScale, isAudioActive){
    // base drift
    this.x += this.vx; this.y += this.vy;

    // diffuse when paused (keeps them spread out)
    if (!isAudioActive) {
      this.vx += (Math.random()-0.5)*0.02;
      this.vy += (Math.random()-0.5)*0.02;
    } else {
      // tiny background noise so it never “freezes”
      this.vx += (Math.random()-0.5)*0.006;
      this.vy += (Math.random()-0.5)*0.006;
    }

    // wrap
    if(this.x<0) this.x = canvas.width; if(this.x>canvas.width) this.x = 0;
    if(this.y<0) this.y = canvas.height; if(this.y>canvas.height) this.y = 0;

    // soft containment toward center — ONLY when there is some music energy
    const cx = canvas.width/2, cy = canvas.height/2;
    const dxc = cx - this.x, dyc = cy - this.y;
    const containStrength = CENTER_CONTAIN * audioEnergy; // 0 when idle
    if (containStrength > 0.0001) {
      this.vx += dxc * containStrength * 0.0015;
      this.vy += dyc * containStrength * 0.0015;
    }

    // pointer attraction (only with recent motion or active press)
    const dxp = pointer.x - this.x, dyp = pointer.y - this.y;
    const distp = Math.hypot(dxp,dyp) || 1;
    const range = isTouch ? 280 : 220;
    const now = performance.now();
    const recent = Math.exp(-(now - pointer.lastMove) / 400); // 0..1 ~400ms
    const pointerFactor = pointer.active ? 1.0 : recent;

    if (distp < range && pointerFactor > 0.02) {
      const f = (1 - distp/range) * 0.12 * pointer.strength * pointerFactor;
      this.vx += (dxp/distp)*f; this.vy += (dyp/distp)*f;
    }

    // music forces (tempered; scaled down when user is interacting)
    const rx = this.x - cx, ry = this.y - cy;
    const rdist = Math.hypot(rx, ry) || 1;

    // core repulsion ONLY when bass/beat present (no push when paused)
    const corePower = (bassN*0.9 + beatBoost*0.4);
    if (corePower > 0 && rdist < CORE_RADIUS) {
      const repel = (1 - rdist/CORE_RADIUS) * 0.8 * corePower;
      this.vx += (rx/rdist) * repel;
      this.vy += (ry/rdist) * repel;
    }

    // Bass: gentle outward breathing
    const bassPush = bassN * 0.45 * musicScale;
    this.vx += (rx/rdist) * bassPush;
    this.vy += (ry/rdist) * bassPush;

    // Mid: swirl
    const tx = -ry/rdist, ty = rx/rdist;
    this.vx += tx * midN * 0.55 * musicScale;
    this.vy += ty * midN * 0.55 * musicScale;

    // Treble: mild jitter
    this.vx += (Math.random() - 0.5) * trebN * 0.35 * musicScale;
    this.vy += (Math.random() - 0.5) * trebN * 0.35 * musicScale;

    // Beat: small extra outward kick
    if (beatBoost > 0.02) {
      this.vx += (rx/rdist) * beatBoost * 0.6 * musicScale;
      this.vy += (ry/rdist) * beatBoost * 0.6 * musicScale;
    }

    // damping
    this.vx *= 0.988; this.vy *= 0.988;

    // size & color
    const targetSize = this.baseSize + bassN*0.7 + beatBoost*0.6 + trebN*0.2;
    this.size = lerp(this.size, targetSize, 0.15);
    const targetHue = (centroidN*320 + bassN*30) % 360;
    this.hue  = lerp(this.hue, targetHue, 0.12);
    this.color = `hsl(${this.hue},100%,${60 + trebN*22}%)`;
  }
  draw(){
    ctx.shadowBlur = 6; ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
  }
}

/* ----- Flares (beat bursts) ----- */
class Flare {
  constructor(){ this.alive=false; this.x=0; this.y=0; this.r=0; this.maxR=0; this.alpha=0; this.hue=0; }
  spawn(cx, cy, hue, power){
    this.alive = true;
    this.x=cx; this.y=cy; this.r=8;
    this.maxR = 120 + power*180;
    this.alpha = 0.22 + power*0.26;
    this.hue = hue;
  }
  update(){ if(!this.alive) return; this.r += 4.5; this.alpha *= 0.92; if(this.r>this.maxR||this.alpha<0.01) this.alive=false; }
  draw(){
    if(!this.alive) return;
    const grad = ctx.createRadialGradient(this.x, this.y, this.r*0.2, this.x, this.y, this.r);
    grad.addColorStop(0, `hsla(${this.hue},100%,70%,${this.alpha})`);
    grad.addColorStop(1, `hsla(${this.hue},100%,50%,0)`);
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
  }
}

const particles = Array.from({length: BASE_PARTICLE_COUNT}, () => new Particle());
const flares = Array.from({length: FLARE_POOL_SIZE}, () => new Flare());

/* ====== Web Audio (dynamic) ====== */
let audioCtx, analyser, dataArray, source, isPlaying=false;
let bassN=0, midN=0, trebN=0, centroidN=0;
let rollPeak = 0.3, rollFloor = 0.05;
let energyLT = 0.10, energyST = 0.10;
const PEAK_DECAY = 0.995, FLOOR_RISE = 0.999;

const btn = document.getElementById("toggleAudio");
btn.addEventListener("click", () => {
  if (!isPlaying) {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.65;
      analyser.minDecibels = -95;
      analyser.maxDecibels = -5;
      dataArray = new Uint8Array(analyser.frequencyBinCount);

      fetch(encodeURI(AUDIO_FILE))
        .then(r => r.arrayBuffer())
        .then(b => audioCtx.decodeAudioData(b))
        .then(decoded => {
          source = audioCtx.createBufferSource();
          source.buffer = decoded;
          source.connect(analyser);
          analyser.connect(audioCtx.destination);
          source.start(0);
          isPlaying = true;
          btn.textContent = "Pause";
        });
    } else {
      audioCtx.resume();
      isPlaying = true;
      btn.textContent = "Pause";
    }
  } else {
    audioCtx.suspend();
    isPlaying = false;
    btn.textContent = "Play";
  }
});

function hzToIndex(hz){
  const nyquist = (audioCtx ? audioCtx.sampleRate : 48000) / 2;
  return Math.round(hz / nyquist * (dataArray.length-1));
}
function bandAvgHz(minHz, maxHz){
  const a = clamp(hzToIndex(minHz), 0, dataArray.length-1);
  const b = clamp(hzToIndex(maxHz), 0, dataArray.length-1);
  let s=0, n=0; for(let i=a;i<=b;i++){ s+=dataArray[i]; n++; }
  return n? s/n : 0;
}
function spectralCentroid(){
  let num=0, den=0;
  const nyquist = (audioCtx ? audioCtx.sampleRate : 48000)/2;
  for(let i=0;i<dataArray.length;i++){
    const f = i/dataArray.length * nyquist;
    const m = dataArray[i];
    num += f*m; den += m;
  }
  return den ? num/den : 0;
}

/* ====== Carousel interaction (reversed default) ====== */
let rotationY = 0;
let rotationSpeed = -0.25;
let dragging = false, lastX = 0;
function applyRotation(){ carousel.style.transform = `rotateY(${rotationY}deg)`; }

addEventListener("mousedown", e => { dragging=true; lastX=e.clientX; markMove(e.clientX, e.clientY); pointer.active=true; });
addEventListener("mousemove", e => { if(dragging){ rotationSpeed = (e.clientX-lastX)*0.1; lastX=e.clientX; } });
addEventListener("mouseup",   () => { dragging=false; pointer.active=false; });

addEventListener("touchstart", e => {
  const t=e.touches[0]; dragging=true; lastX=t.clientX; markMove(t.clientX, t.clientY); pointer.active=true;
},{passive:false});
addEventListener("touchmove", e => {
  e.preventDefault();
  const t=e.touches[0];
  if(dragging){ rotationSpeed = (t.clientX-lastX)*0.1; lastX=t.clientX; }
  markMove(t.clientX, t.clientY);
},{passive:false});
addEventListener("touchend",  () => { dragging=false; pointer.active=false; });

/* ====== Main loop (balanced, no idle center pull) ====== */
let camShakeX = 0, camShakeY = 0, camZoom = 0;

function animate(){
  // audio analysis
  let beatBoost = 0;
  if(isPlaying && analyser){
    analyser.getByteFrequencyData(dataArray);
    const bRaw = bandAvgHz(25, 160);
    const mRaw = bandAvgHz(160, 2200);
    const tRaw = bandAvgHz(2200, 9000);
    const b01 = bRaw/255, m01 = mRaw/255, t01 = tRaw/255;

    rollPeak = Math.max(rollPeak*PEAK_DECAY, b01, m01, t01);
    rollFloor = Math.min(rollFloor/FLOOR_RISE, b01, m01, t01);
    const span = Math.max(0.06, rollPeak - rollFloor);

    // normalize + gentle smoothing
    const nb = clamp((b01 - rollFloor)/span, 0, 1);
    const nm = clamp((m01 - rollFloor)/span, 0, 1);
    const nt = clamp((t01 - rollFloor)/span, 0, 1);
    bassN = lerp(bassN, nb, 0.28);
    midN  = lerp(midN,  nm, 0.28);
    trebN = lerp(trebN, nt, 0.28);

    const scHz = spectralCentroid();
    const nyquist = audioCtx.sampleRate/2;
    centroidN = clamp(scHz / nyquist, 0, 1);

    const instantEnergy = (b01*1.7 + m01*1.1 + t01*0.6) / 3.4;
    energyST = lerp(energyST, instantEnergy, 0.30);
    energyLT = lerp(energyLT, instantEnergy, 0.02);
    const diff = energyST - energyLT;
    beatBoost = diff > 0 ? diff*1.4 : 0;

    // compute overall energy (0..1) to drive containment
    audioEnergy = clamp((bassN + midN + trebN) / 3, 0, 1);

    // subtle camera pulse
    camShakeX = lerp(camShakeX, (Math.random()-0.5) * beatBoost * 10, 0.4);
    camShakeY = lerp(camShakeY, (Math.random()-0.5) * beatBoost * 10, 0.4);
    camZoom   = lerp(camZoom, beatBoost * 0.015, 0.4);

    // occasional flare on stronger beats
    if (beatBoost > 0.05) {
      const hue = (centroidN*320 + bassN*40) % 360;
      const f = flares.find(fl => !fl.alive);
      if (f) f.spawn(innerWidth/2, innerHeight/2, hue, beatBoost);
    }
  } else {
    // decay to calm when paused
    bassN = lerp(bassN, 0, 0.15);
    midN  = lerp(midN,  0, 0.15);
    trebN = lerp(trebN, 0, 0.15);
    centroidN = lerp(centroidN, 0.3, 0.05);
    audioEnergy = lerp(audioEnergy, 0, 0.2); // turn containment fully off
    camShakeX *= 0.9; camShakeY *= 0.9; camZoom *= 0.9;
  }

  // Reduce music dominance when there's active/recent pointer motion
  const now = performance.now();
  const recent = Math.exp(-(now - pointer.lastMove) / 400);
  const pointerInfluence = pointer.active ? 0.7 : (recent * 0.45);
  const musicScale = 1 - clamp(pointerInfluence, 0, 0.85);

  // canvas transform
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const zoom = 1 + camZoom;
  ctx.translate(camShakeX + canvas.width/2, camShakeY + canvas.height/2);
  ctx.scale(zoom, zoom);
  ctx.translate(-canvas.width/2, -canvas.height/2);

  // particles
  const isAudioActive = isPlaying && audioEnergy > 0.02;
  for(const p of particles){ p.update(bassN, midN, trebN, centroidN, beatBoost, musicScale, isAudioActive); p.draw(); }

  // flares
  ctx.globalCompositeOperation = 'lighter';
  for(const fl of flares){ fl.update(); fl.draw(); }
  ctx.globalCompositeOperation = 'source-over';

  // carousel rotation
  rotationY += rotationSpeed;
  if(!dragging){ rotationSpeed = lerp(rotationSpeed, -0.25, 0.06); }
  applyRotation();

  // panel glow
  const hue = (centroidN*320 + bassN*30) % 360;
  const glowSize = Math.max(10, trebN*26 + beatBoost*28);
  const glow = `0 0 ${glowSize}px hsl(${hue}, 100%, 60%)`;
  panels.forEach(el => el.style.textShadow = "");
  let idx = Math.round(rotationY / (360 / panelCount)) % panelCount; if (idx < 0) idx += panelCount;
  panels[idx].style.textShadow = glow;

  // ring shimmer
  ring.style.opacity = String(0.25 + trebN * 0.24);

  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>