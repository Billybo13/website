<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI + Humanity — Home</title>
<style>
:root{
  --bg:#071021;
  --accent: #8be9fd;
  --quote-color: #e6f7ff;
}
html,body{
  height:100%;margin:0;
  background:var(--bg);
  font-family:Inter, sans-serif;
}
.wrap{
  min-height:100vh;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:40px;
  padding:40px;
  box-sizing:border-box;
}
.hero{
  width:760px;
  max-width:90vw;
  height:460px;
  background:rgba(255,255,255,0.03);
  border-radius:14px;
  padding:28px;
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  color:white;
}
.title{
  color:var(--accent);
  font-weight:700;
  font-size:20px;
}
.sub{
  color:rgba(255,255,255,0.6);
  font-size:13px;
}
.carousel{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
}
.quote-card{
  width:640px;
  max-width:86%;
  padding:28px;
  background:rgba(255,255,255,0.02);
  border-radius:12px;
  color:var(--quote-color);
  font-size:22px;
  line-height:1.5;
  text-align:center;
  transition: transform 0.3s ease, opacity 0.3s ease;
}
.bounce{
  animation: bounceScale 360ms cubic-bezier(.3,.9,.3,1);
}
@keyframes bounceScale {
  0%{ transform: translateY(0) scale(1); }
  30%{ transform: translateY(-10px) scale(1.03); }
  100%{ transform: translateY(0) scale(1); }
}
.controls{
  width:360px;
  max-width:38vw;
  height:460px;
  background:rgba(255,255,255,0.03);
  border-radius:14px;
  padding:20px;
  display:flex;
  flex-direction:column;
  gap:12px;
  color:white;
}
button.play{
  background:linear-gradient(90deg,#10b981,#06b6d4);
  color:white;border:0;padding:10px 16px;
  border-radius:10px;font-weight:600;cursor:pointer;
}
.mute{
  background:transparent;
  border:1px solid rgba(255,255,255,0.2);
  color:white;
  padding:8px 10px;
  border-radius:10px;
  cursor:pointer;
}
.slider{flex:1;}
input[type=range]{width:100%;}
.canvas-wrap{flex:1;border-radius:10px;overflow:hidden;}
canvas{width:100%;height:100%;display:block;}
</style>
</head>
<body>
<div class="wrap">
  <section class="hero">
    <div>
      <div class="title">AI & Humanity — Ahead</div>
      <div class="sub">Rotating thoughts on technology guiding human flourishing</div>
    </div>
    <div class="carousel">
      <div class="quote-card" id="quoteCard"></div>
    </div>
  </section>
  <aside class="controls">
    <div style="display:flex;gap:8px;">
      <button class="play" id="btnPlay">Play</button>
      <button class="mute" id="btnMute">Mute</button>
    </div>
    <div class="slider">
      Volume:
      <input id="volume" type="range" min="0" max="1" step="0.01" value="0.8">
    </div>
    <div class="canvas-wrap">
      <canvas id="particles"></canvas>
    </div>
  </aside>
</div>

<script>
// ===== Quotes =====
const quotes = [
  "AI can be a compass — guiding societies toward wiser decisions.",
  "When designed with empathy, AI amplifies human capacity.",
  "Augmented intelligence lets us see patterns we couldn't before.",
  "AI is a collaborator — magnifying our best intentions.",
  "Technology that augments human judgment can help democracy.",
  "From medicine to farming, AI’s insights can unlock human flourishing.",
  "The future isn't AI vs humans — it’s AI + humans co-creating."
];
let currentQuote = 0;
const quoteCard = document.getElementById('quoteCard');
quoteCard.textContent = quotes[0];

// ===== Canvas & Particles =====
const canvas = document.getElementById('particles');
const ctx = canvas.getContext('2d');
let cw, ch;
function resizeCanvas(){
  cw = canvas.width = canvas.clientWidth * window.devicePixelRatio;
  ch = canvas.height = canvas.clientHeight * window.devicePixelRatio;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

class Particle {
  constructor(x,y,vx,vy,color,life,size){
    this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.color=color;this.life=life;this.maxLife=life;this.size=size;
  }
  update(dt){this.x+=this.vx*dt;this.y+=this.vy*dt;this.life-=dt;}
  draw(ctx){
    ctx.globalAlpha = Math.max(0,this.life/this.maxLife);
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}
let particles = [];
function spawnParticles(count,color,intensity){
  const speed = intensity * 4; // faster
  for(let i=0;i<count;i++){
    const angle = Math.random() * Math.PI * 2;
    const velocity = (Math.random() * 1.5 + 0.5) * speed;
    const vx = Math.cos(angle) * velocity;
    const vy = Math.sin(angle) * velocity;
    const size = Math.random() * 3 + 2;
    const life = 80 + Math.random() * 40;
    particles.push(new Particle(cw/2, ch/2, vx, vy, color, life, size));
  }
}

// ===== Audio Setup (fetch + decode) =====
let audioCtx, analyser, dataArray, gainNode;
let isPlaying = false;
let storedBuffer = null;
let bufferSource = null;

async function initAudio(){
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  dataArray = new Uint8Array(analyser.frequencyBinCount);
  gainNode = audioCtx.createGain();
  gainNode.gain.value = document.getElementById('volume').value;
  analyser.connect(audioCtx.destination);

  const resp = await fetch('goldberg_variations.mp3');
  const buf = await resp.arrayBuffer();
  storedBuffer = await audioCtx.decodeAudioData(buf);
}

function playBuffer(){
  bufferSource = audioCtx.createBufferSource();
  bufferSource.buffer = storedBuffer;
  bufferSource.connect(gainNode);
  gainNode.connect(analyser);
  bufferSource.start();
  bufferSource.onended = () => {
    isPlaying = false;
    document.getElementById('btnPlay').textContent = "Play";
  };
}

// ===== Animation =====
let lastTime = performance.now();
function animate(t){
  const dt = (t - lastTime)/16;
  lastTime = t;
  ctx.fillStyle = "rgba(0,0,0,0.2)";
  ctx.fillRect(0,0,cw,ch);

  analyser.getByteFrequencyData(dataArray);
  const low = avgFreq(20,250);
  const mid = avgFreq(250,2000);
  const high = avgFreq(2000,8000);

  if(low > 30) spawnParticles(2,"#ff6b35",low/50);
  if(mid > 25) spawnParticles(2,"#34d399",mid/50);
  if(high > 20) spawnParticles(2,"#7c3aed",high/50);

  particles.forEach(p=>p.update(dt));
  particles = particles.filter(p=>p.life>0);
  particles.forEach(p=>p.draw(ctx));

  // Change quote on strong bass beat
  if(low > 50){
    quoteCard.classList.remove('bounce');
    void quoteCard.offsetWidth;
    quoteCard.classList.add('bounce');
    currentQuote = (currentQuote+1)%quotes.length;
    quoteCard.textContent = quotes[currentQuote];
  }

  if(isPlaying) requestAnimationFrame(animate);
}

function avgFreq(minHz, maxHz) {
  const nyquist = audioCtx.sampleRate / 2;
  const lowIndex = Math.floor(minHz / nyquist * dataArray.length);
  const highIndex = Math.min(dataArray.length - 1, Math.floor(maxHz / nyquist * dataArray.length));
  let sum = 0;
  let count = 0;
  for (let i = lowIndex; i <= highIndex; i++) {
    sum += dataArray[i];
    count++;
  }
  return count ? sum / count : 0;
}

// ===== Controls =====
document.getElementById('btnPlay').addEventListener('click', async ()=>{
  if(!audioCtx){
    await initAudio();
  }
  if(!isPlaying){
    if(audioCtx.state === "suspended") await audioCtx.resume();
    playBuffer();
    isPlaying = true;
    document.getElementById('btnPlay').textContent = "Pause";
    requestAnimationFrame(animate);
  } else {
    audioCtx.suspend();
    isPlaying = false;
    document.getElementById('btnPlay').textContent = "Play";
  }
});

document.getElementById('btnMute').addEventListener('click', ()=>{
  if(!audioCtx) return;
  gainNode.gain.value = gainNode.gain.value>0 ? 0 : document.getElementById('volume').value;
});

document.getElementById('volume').addEventListener('input', (e)=>{
  if(!audioCtx) return;
  gainNode.gain.value = parseFloat(e.target.value);
});
</script>
</body>
</html>
